// Vercel API wrapper for MCP server
// Auto-generated by Poke MCP deployment workflow
// Spawns the MCP server as a subprocess and communicates via stdin/stdout

const { spawn } = require('child_process');
const path = require('path');

export default async function handler(req, res) {
  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
    res.status(204).end();
    return;
  }

  res.setHeader('Access-Control-Allow-Origin', '*');

  // Parse the incoming request body for MCP JSON-RPC
  let body = '';
  for await (const chunk of req) {
    body += chunk;
  }

  let jsonBody;
  try {
    jsonBody = JSON.parse(body);
  } catch (e) {
    res.status(400).json({
      jsonrpc: '2.0',
      error: {
        code: -32700,
        message: 'Parse error: ' + e.message
      },
      id: null
    });
    return;
  }

  // Parse credentials from Authorization header
  // Credentials include both user tokens (accessToken, refreshToken) and can include app credentials
  const authHeader = req.headers.authorization || '';
  let credentials = {};

  console.log('[MCP_API] Authorization header present:', !!authHeader);
  console.log('[MCP_API] Authorization header starts with Bearer:', authHeader.startsWith('Bearer '));

  if (authHeader.startsWith('Bearer ')) {
    try {
      const decoded = Buffer.from(authHeader.slice(7), 'base64').toString();
      credentials = JSON.parse(decoded);
      console.log('[MCP_API] Decoded credentials keys:', Object.keys(credentials));
      console.log('[MCP_API] Has clientId:', !!credentials.clientId);
      console.log('[MCP_API] Has clientSecret:', !!credentials.clientSecret);
      console.log('[MCP_API] Has accessToken:', !!credentials.accessToken);
      console.log('[MCP_API] Has refreshToken:', !!credentials.refreshToken);
    } catch (e) {
      console.log('[MCP_API] Failed to parse base64 credentials, using as plain token:', e.message);
      // Fallback: treat as plain access token
      credentials = { accessToken: authHeader.slice(7) };
    }
  } else {
    console.log('[MCP_API] No Bearer token found in Authorization header');
  }

  // Build environment with ALL credentials injected
  // This allows the MCP server to be completely stateless - all config comes from the request
  // App-level credentials (clientId, clientSecret) come from Vercel env vars as fallback
  const env = {
    ...process.env,
    // User's OAuth tokens (per-request, from Authorization header)
    SPOTIFY_ACCESS_TOKEN: credentials.accessToken || '',
    SPOTIFY_REFRESH_TOKEN: credentials.refreshToken || '',
    // App credentials - prefer from request, fallback to Vercel env vars
    SPOTIFY_CLIENT_ID: credentials.clientId || process.env.SPOTIFY_CLIENT_ID || '',
    SPOTIFY_CLIENT_SECRET: credentials.clientSecret || process.env.SPOTIFY_CLIENT_SECRET || '',
    SPOTIFY_REDIRECT_URI: credentials.redirectUri || process.env.SPOTIFY_REDIRECT_URI || 'http://localhost:8888/callback',
    // Generic MCP credential env vars (for servers that use standard naming)
    MCP_ACCESS_TOKEN: credentials.accessToken || '',
    MCP_REFRESH_TOKEN: credentials.refreshToken || '',
    MCP_CLIENT_ID: credentials.clientId || process.env.MCP_CLIENT_ID || '',
    MCP_CLIENT_SECRET: credentials.clientSecret || process.env.MCP_CLIENT_SECRET || '',
  };

  // Spawn the MCP server from the build directory
  // The patched utils.ts reads credentials from env vars, making the server stateless
  const serverPath = path.join(__dirname, '..', 'build', 'index.js');

  return new Promise((resolve) => {
    const timeout = setTimeout(() => {
      res.status(504).json({
        jsonrpc: '2.0',
        error: {
          code: -32000,
          message: 'Server timeout'
        },
        id: jsonBody.id
      });
      resolve();
    }, 25000);

    let responseData = '';
    let stderrData = '';

    const serverProcess = spawn('node', [serverPath], {
      stdio: ['pipe', 'pipe', 'pipe'],
      env
    });

    serverProcess.stdout.on('data', (data) => {
      responseData += data.toString();
    });

    serverProcess.stderr.on('data', (data) => {
      stderrData += data.toString();
    });

    serverProcess.on('close', (code) => {
      clearTimeout(timeout);

      // Parse the response - MCP servers output JSON-RPC on stdout
      const lines = responseData.trim().split('\n');
      for (let i = lines.length - 1; i >= 0; i--) {
        const line = lines[i].trim();
        if (!line) continue;
        try {
          const parsed = JSON.parse(line);
          if (typeof parsed === 'object' && parsed !== null && 'jsonrpc' in parsed) {
            res.status(200).json(parsed);
            resolve();
            return;
          }
        } catch {
          // Continue to next line
        }
      }

      // JSON-RPC notifications (requests without 'id') don't expect a response
      // Per JSON-RPC 2.0 spec: "A Notification is a Request object without an 'id' member"
      // Return 204 No Content for successful notification processing
      if (jsonBody.id === undefined) {
        // If there was stderr output indicating an error, still report it
        if (stderrData && stderrData.trim()) {
          res.status(500).json({
            jsonrpc: '2.0',
            error: {
              code: -32000,
              message: 'Server error: ' + stderrData.substring(0, 200)
            },
            id: null
          });
        } else {
          // Successful notification - no response needed
          res.status(204).end();
        }
        resolve();
        return;
      }

      // No valid response found for a request that expected one
      res.status(500).json({
        jsonrpc: '2.0',
        error: {
          code: -32000,
          message: 'No valid response from server' + (stderrData ? ': ' + stderrData.substring(0, 200) : '')
        },
        id: jsonBody.id
      });
      resolve();
    });

    serverProcess.on('error', (err) => {
      clearTimeout(timeout);
      res.status(500).json({
        jsonrpc: '2.0',
        error: {
          code: -32000,
          message: 'Failed to spawn server: ' + err.message
        },
        id: jsonBody.id
      });
      resolve();
    });

    // Send the request to stdin
    serverProcess.stdin.write(JSON.stringify(jsonBody) + '\n');
    serverProcess.stdin.end();
  });
}
