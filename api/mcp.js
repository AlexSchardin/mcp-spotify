// Vercel API wrapper for MCP server
// Auto-generated by Poke MCP deployment workflow
// Spawns the MCP server as a subprocess and communicates via stdin/stdout
// UNIVERSAL: Handles both file-based and env-based credential loading

const { spawn } = require('child_process');
const path = require('path');
const fs = require('fs');
const os = require('os');

// Configuration from deployment analysis
const CONFIG_FILE_PATH = "spotify-config.json";
const LOADING_PATTERN = "file";
const REQUIRED_CREDENTIALS = [{"name":"clientId","envName":null,"description":"Spotify OAuth client ID","isAppCredential":true},{"name":"clientSecret","envName":null,"description":"Spotify OAuth client secret","isAppCredential":true},{"name":"redirectUri","envName":null,"description":"OAuth redirect URI","isAppCredential":true},{"name":"accessToken","envName":null,"description":"OAuth access token (obtained via auth flow)","isAppCredential":false},{"name":"refreshToken","envName":null,"description":"OAuth refresh token (obtained via auth flow)","isAppCredential":false}];

export default async function handler(req, res) {
  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
    res.status(204).end();
    return;
  }

  res.setHeader('Access-Control-Allow-Origin', '*');

  // Parse the incoming request body for MCP JSON-RPC
  let body = '';
  for await (const chunk of req) {
    body += chunk;
  }

  let jsonBody;
  try {
    jsonBody = JSON.parse(body);
  } catch (e) {
    res.status(400).json({
      jsonrpc: '2.0',
      error: {
        code: -32700,
        message: 'Parse error: ' + e.message
      },
      id: null
    });
    return;
  }

  // Parse credentials from Authorization header
  const authHeader = req.headers.authorization || '';
  let credentials = {};

  console.log('[MCP_API] Authorization header present:', !!authHeader);
  console.log('[MCP_API] Loading pattern:', LOADING_PATTERN);
  console.log('[MCP_API] Config file path:', CONFIG_FILE_PATH);

  if (authHeader.startsWith('Bearer ')) {
    try {
      const decoded = Buffer.from(authHeader.slice(7), 'base64').toString();
      credentials = JSON.parse(decoded);
      console.log('[MCP_API] Decoded credentials keys:', Object.keys(credentials));
    } catch (e) {
      console.log('[MCP_API] Failed to parse base64 credentials, using as plain token:', e.message);
      credentials = { accessToken: authHeader.slice(7) };
    }
  }

  // Build environment with ALL credentials injected (for env-based servers)
  // This is a universal approach - set all common env var patterns
  const env = {
    ...process.env,
    // Generic MCP credential env vars
    MCP_ACCESS_TOKEN: credentials.accessToken || '',
    MCP_REFRESH_TOKEN: credentials.refreshToken || '',
    MCP_CLIENT_ID: credentials.clientId || process.env.MCP_CLIENT_ID || '',
    MCP_CLIENT_SECRET: credentials.clientSecret || process.env.MCP_CLIENT_SECRET || '',
    MCP_API_KEY: credentials.apiKey || process.env.MCP_API_KEY || '',
    // Spotify-specific (for backwards compatibility)
    SPOTIFY_ACCESS_TOKEN: credentials.accessToken || '',
    SPOTIFY_REFRESH_TOKEN: credentials.refreshToken || '',
    SPOTIFY_CLIENT_ID: credentials.clientId || process.env.SPOTIFY_CLIENT_ID || '',
    SPOTIFY_CLIENT_SECRET: credentials.clientSecret || process.env.SPOTIFY_CLIENT_SECRET || '',
  };

  // Add credentials as env vars using their configured envName
  for (const cred of REQUIRED_CREDENTIALS) {
    if (cred.envName && credentials[cred.name]) {
      env[cred.envName] = credentials[cred.name];
    }
  }

  // For file-based servers, write credentials to the expected config file
  let tempConfigDir = null;
  if (LOADING_PATTERN === 'file') {
    try {
      // Create a temp directory for the config file
      tempConfigDir = fs.mkdtempSync(path.join(os.tmpdir(), 'mcp-config-'));

      // Build config object from credentials
      const configObject = {};
      for (const cred of REQUIRED_CREDENTIALS) {
        const credName = cred.configPath || cred.name;
        if (credentials[cred.name]) {
          configObject[credName] = credentials[cred.name];
        } else if (cred.isAppCredential && process.env[cred.envName]) {
          // For app credentials, use env vars
          configObject[credName] = process.env[cred.envName];
        }
      }

      // Also add common credential names if not already present
      if (credentials.clientId && !configObject.clientId) configObject.clientId = credentials.clientId;
      if (credentials.clientSecret && !configObject.clientSecret) configObject.clientSecret = credentials.clientSecret;
      if (credentials.accessToken && !configObject.accessToken) configObject.accessToken = credentials.accessToken;
      if (credentials.refreshToken && !configObject.refreshToken) configObject.refreshToken = credentials.refreshToken;
      if (!configObject.redirectUri) configObject.redirectUri = 'http://localhost:8888/callback';

      // Write the config file
      const configPath = path.join(tempConfigDir, path.basename(CONFIG_FILE_PATH));
      fs.writeFileSync(configPath, JSON.stringify(configObject, null, 2));

      console.log('[MCP_API] Wrote config file to:', configPath);
      console.log('[MCP_API] Config keys:', Object.keys(configObject));

      // Set cwd to temp dir so relative paths work (e.g., ../spotify-config.json)
      // Many servers use paths relative to their build dir
    } catch (e) {
      console.error('[MCP_API] Failed to write config file:', e.message);
    }
  }

  // Determine the server path and working directory
  const serverPath = path.join(__dirname, '..', 'build', 'index.js');

  // For file-based servers, also write config adjacent to build dir
  if (LOADING_PATTERN === 'file' && tempConfigDir) {
    try {
      // Write config file relative to the server build directory
      // Many servers look for ../CONFIG_FILE from build/index.js
      const buildDir = path.join(__dirname, '..', 'build');
      const parentDir = path.join(__dirname, '..');

      // Write to multiple possible locations the server might look
      const configLocations = [
        path.join(parentDir, path.basename(CONFIG_FILE_PATH)),  // ../config.json
        path.join(buildDir, path.basename(CONFIG_FILE_PATH)),   // build/config.json
        path.join(__dirname, path.basename(CONFIG_FILE_PATH)),  // api/config.json
      ];

      const configObject = {};
      for (const cred of REQUIRED_CREDENTIALS) {
        const credName = cred.configPath || cred.name;
        if (credentials[cred.name]) {
          configObject[credName] = credentials[cred.name];
        } else if (cred.isAppCredential && process.env[cred.envName]) {
          configObject[credName] = process.env[cred.envName];
        }
      }
      if (credentials.clientId && !configObject.clientId) configObject.clientId = credentials.clientId;
      if (credentials.clientSecret && !configObject.clientSecret) configObject.clientSecret = credentials.clientSecret;
      if (credentials.accessToken && !configObject.accessToken) configObject.accessToken = credentials.accessToken;
      if (credentials.refreshToken && !configObject.refreshToken) configObject.refreshToken = credentials.refreshToken;
      if (!configObject.redirectUri) configObject.redirectUri = 'http://localhost:8888/callback';

      for (const loc of configLocations) {
        try {
          fs.writeFileSync(loc, JSON.stringify(configObject, null, 2));
          console.log('[MCP_API] Also wrote config to:', loc);
        } catch (e) {
          console.log('[MCP_API] Could not write config to:', loc, '-', e.message);
        }
      }
    } catch (e) {
      console.error('[MCP_API] Failed to write additional config files:', e.message);
    }
  }

  return new Promise((resolve) => {
    const timeout = setTimeout(() => {
      res.status(504).json({
        jsonrpc: '2.0',
        error: {
          code: -32000,
          message: 'Server timeout'
        },
        id: jsonBody.id
      });
      resolve();
    }, 25000);

    let responseData = '';
    let stderrData = '';

    const serverProcess = spawn('node', [serverPath], {
      stdio: ['pipe', 'pipe', 'pipe'],
      env
    });

    serverProcess.stdout.on('data', (data) => {
      responseData += data.toString();
    });

    serverProcess.stderr.on('data', (data) => {
      stderrData += data.toString();
    });

    serverProcess.on('close', (code) => {
      clearTimeout(timeout);

      // Clean up temp config dir
      if (tempConfigDir) {
        try {
          fs.rmSync(tempConfigDir, { recursive: true, force: true });
        } catch (e) {
          console.log('[MCP_API] Failed to cleanup temp dir:', e.message);
        }
      }

      // Parse the response - MCP servers output JSON-RPC on stdout
      const lines = responseData.trim().split('\n');
      for (let i = lines.length - 1; i >= 0; i--) {
        const line = lines[i].trim();
        if (!line) continue;
        try {
          const parsed = JSON.parse(line);
          if (typeof parsed === 'object' && parsed !== null && 'jsonrpc' in parsed) {
            res.status(200).json(parsed);
            resolve();
            return;
          }
        } catch {
          // Continue to next line
        }
      }

      // JSON-RPC notifications don't expect a response
      if (jsonBody.id === undefined) {
        if (stderrData && stderrData.trim()) {
          res.status(500).json({
            jsonrpc: '2.0',
            error: {
              code: -32000,
              message: 'Server error: ' + stderrData.substring(0, 200)
            },
            id: null
          });
        } else {
          res.status(204).end();
        }
        resolve();
        return;
      }

      // No valid response found
      res.status(500).json({
        jsonrpc: '2.0',
        error: {
          code: -32000,
          message: 'No valid response from server' + (stderrData ? ': ' + stderrData.substring(0, 200) : '')
        },
        id: jsonBody.id
      });
      resolve();
    });

    serverProcess.on('error', (err) => {
      clearTimeout(timeout);
      if (tempConfigDir) {
        try {
          fs.rmSync(tempConfigDir, { recursive: true, force: true });
        } catch (e) { /* ignore */ }
      }
      res.status(500).json({
        jsonrpc: '2.0',
        error: {
          code: -32000,
          message: 'Failed to spawn server: ' + err.message
        },
        id: jsonBody.id
      });
      resolve();
    });

    // Send the request to stdin
    serverProcess.stdin.write(JSON.stringify(jsonBody) + '\n');
    serverProcess.stdin.end();
  });
}
