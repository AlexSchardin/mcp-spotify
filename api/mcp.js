// Vercel API wrapper for MCP server
// Auto-generated by Poke MCP deployment workflow
// Spawns the MCP server as a subprocess and communicates via stdin/stdout

import { spawn } from 'child_process';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

export default async function handler(req, res) {
  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
    res.status(204).end();
    return;
  }

  res.setHeader('Access-Control-Allow-Origin', '*');

  // Parse the incoming request body for MCP JSON-RPC
  let body = '';
  for await (const chunk of req) {
    body += chunk;
  }

  let jsonBody;
  try {
    jsonBody = JSON.parse(body);
  } catch (e) {
    res.status(400).json({
      jsonrpc: '2.0',
      error: {
        code: -32700,
        message: 'Parse error: ' + e.message
      },
      id: null
    });
    return;
  }

  // Parse credentials from Authorization header
  // Credentials include both user tokens (accessToken, refreshToken) and can include app credentials
  const authHeader = req.headers.authorization || '';
  let credentials = {};

  if (authHeader.startsWith('Bearer ')) {
    try {
      credentials = JSON.parse(Buffer.from(authHeader.slice(7), 'base64').toString());
    } catch (e) {
      // Fallback: treat as plain access token
      credentials = { accessToken: authHeader.slice(7) };
    }
  }

  // Build environment with ALL credentials injected
  // This allows the MCP server to be completely stateless - all config comes from the request
  // App-level credentials (clientId, clientSecret) come from Vercel env vars as fallback
  const env = {
    ...process.env,
    // User's OAuth tokens (per-request, from Authorization header)
    SPOTIFY_ACCESS_TOKEN: credentials.accessToken || '',
    SPOTIFY_REFRESH_TOKEN: credentials.refreshToken || '',
    // App credentials - prefer from request, fallback to Vercel env vars
    SPOTIFY_CLIENT_ID: credentials.clientId || process.env.SPOTIFY_CLIENT_ID || '',
    SPOTIFY_CLIENT_SECRET: credentials.clientSecret || process.env.SPOTIFY_CLIENT_SECRET || '',
    SPOTIFY_REDIRECT_URI: credentials.redirectUri || process.env.SPOTIFY_REDIRECT_URI || 'http://localhost:8888/callback',
    // Generic MCP credential env vars (for servers that use standard naming)
    MCP_ACCESS_TOKEN: credentials.accessToken || '',
    MCP_REFRESH_TOKEN: credentials.refreshToken || '',
    MCP_CLIENT_ID: credentials.clientId || process.env.MCP_CLIENT_ID || '',
    MCP_CLIENT_SECRET: credentials.clientSecret || process.env.MCP_CLIENT_SECRET || '',
  };

  // Spawn the MCP server from the build directory
  // The patched utils.ts reads credentials from env vars, making the server stateless
  const serverPath = join(__dirname, '..', 'build', 'index.js');

  return new Promise((resolve) => {
    const timeout = setTimeout(() => {
      res.status(504).json({
        jsonrpc: '2.0',
        error: {
          code: -32000,
          message: 'Server timeout'
        },
        id: jsonBody.id
      });
      resolve();
    }, 25000);

    let responseData = '';
    let stderrData = '';

    const serverProcess = spawn('node', [serverPath], {
      stdio: ['pipe', 'pipe', 'pipe'],
      env
    });

    serverProcess.stdout.on('data', (data) => {
      responseData += data.toString();
    });

    serverProcess.stderr.on('data', (data) => {
      stderrData += data.toString();
    });

    serverProcess.on('close', (code) => {
      clearTimeout(timeout);

      // Parse the response - MCP servers output JSON-RPC on stdout
      const lines = responseData.trim().split('\n');
      for (let i = lines.length - 1; i >= 0; i--) {
        const line = lines[i].trim();
        if (!line) continue;
        try {
          const parsed = JSON.parse(line);
          if (typeof parsed === 'object' && parsed !== null && 'jsonrpc' in parsed) {
            res.status(200).json(parsed);
            resolve();
            return;
          }
        } catch {
          // Continue to next line
        }
      }

      // No valid response found
      res.status(500).json({
        jsonrpc: '2.0',
        error: {
          code: -32000,
          message: 'No valid response from server' + (stderrData ? ': ' + stderrData.substring(0, 200) : '')
        },
        id: jsonBody.id
      });
      resolve();
    });

    serverProcess.on('error', (err) => {
      clearTimeout(timeout);
      res.status(500).json({
        jsonrpc: '2.0',
        error: {
          code: -32000,
          message: 'Failed to spawn server: ' + err.message
        },
        id: jsonBody.id
      });
      resolve();
    });

    // Send the request to stdin
    serverProcess.stdin.write(JSON.stringify(jsonBody) + '\n');
    serverProcess.stdin.end();
  });
}
